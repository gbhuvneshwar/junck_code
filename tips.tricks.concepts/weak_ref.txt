Python Weak References:

The weakref module in the Python standard library is a useful tool for creating Python references without 
impeding object destruction.

import weakref
>>> a = Foo()
created
>>> b = weakref.ref(a)

objects continue to live until the interpreter exits.


A temporary strong reference can be created from a weak reference by calling it:

>>> a == b()
True
>>> b().show()
None
Notice that when we delete the one and only strong reference to our Foo object, it is immediately destroyed:

>>> del a
destroyed
If we try to call our weak reference after the object has been destroyed, we get None in its place:

>>> b() is None
True
As a more transparent alternative to weakref.ref, we can use weakref.proxy. This call requires a strong reference to an object as its first argument and returns a weak reference proxy. The proxy behaves just like a strong reference, but throws an exception when used after the target is dead:

>>> a = Foo()
created
>>> b = weakref.proxy(a)
>>> b.store('fish')
>>> b.show()
fish
>>> del a
destroyed
>>> b.show()
Traceback (most recent call last):
  File "", line 1, in ?
ReferenceError: weakly-referenced object no longer exists


Cyclic references:

A need for weak references arises when objects have strong references forming a cycle. 
In this case, object a has a reference to b and vice versa:

>>> a = Foo()
created
>>> b = Foo()
created
>>> a.store(b)
>>> b.store(a)
>>> del a
>>> del b
The destructor methods on a and b are never called and the objects continue to live 
until the interpreter exits. This example may seem contrived, 
but it is representative of patterns having a bidirectional relationship. 
If a parent GUI widget has a reference to a child widget while the child has a
reference to its container parent, a cyclic reference exists. 
A node in a doubly linked list has a cyclic relationship. Even a node in a singly linked list may
 be part of a cycle that impedes proper object destruction:

>>> a = Foo()
created
>>> b = Foo()
created
>>> c = Foo()
created
>>> a.store(b)
>>> b.store(c)
>>> c.store(a)
>>> del a

>>> del b
>>> del c

A solution to this problem is to store weak references:

class Foo(object):

    ...

    def show(self):
        print self.obj()

    def store(self, obj):
        self.obj = weakref.ref(obj)


With this implementation, the two objects are destroyed when strong references a and b are deleted:

>>> a = Foo()
created
>>> b = Foo()
created
>>> c = Foo()
created
>>> a.store(b)
>>> b.store(c)
>>> c.store(a)
>>> del a
destroyed
>>> del b
destroyed
>>> del c
destroyed

https://mindtrove.info/python-weak-references/