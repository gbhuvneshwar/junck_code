-> List is a sequence of any comination of data type
-> List are mutable
-> List Slice
-> List Method (insert(0,11) by index, multiplcation [0]* 2, [1] + [2], pop by index for removing, remove by elemnt name, append, extend, del[:1] using slice)
-> Map, Filter, Reduce
-> Conver list into string, and string into list (split, join method, slice, strip)
-> count provide the no of times elements are occured
-> reverse()
-> sort()
-> list maintain order
-> find index of no , l1.index()
-> l.copy, l.clear()
--> append(n) method complexity is o(1)
--> insert(1,n) complexity is o(n)
--> When you pop the last element: l.pop(), listpop() is called, Pop operation complexity is O(1).
--> Remove operation complexity is O(n)
->  Sort is O(n log n)
-> pop(0), by index no becomes equivalent to remove, which is O(n) for a basic list
-> Appending n elements is O(n). For n = 1000, the list is going to be resized 27 times.
   The growth pattern is the following: 4, 8, 16, 25, 35, 46, 58, 72, 88, 106, 126, 148, 173, 201, 233, 269, 
   309, 354, 405, 462, 526, 598, 679, 771, 874, 990, 1120. This means 27 calls to realloc.
   It doesn’t change the complexity. It is still O(n).


Lists:
                               Complexity
Operation     | Example      | Class         | Notes
--------------+--------------+---------------+-------------------------------
Index         | l[i]         | O(1)	     |---> which will give you where your index no using item value
Store         | l[i] = 0     | O(1)	     |---> it is removing the older references of item and assigning the new object
Length        | len(l)       | O(1)	     |--> count stratinf point and ending point
Append        | l.append(5)  | O(1)	     | mostly: ICS-46 covers details
Pop	      | l.pop()      | O(1)	     | same as l.pop(-1), popping at end
Clear         | l.clear()    | O(1)	     | similar to l = []

Slice         | l[a:b]       | O(b-a)	     | l[1:5]:O(l)/l[:]:O(len(l)-0)=O(N)
Extend        | l.extend(...)| O(len(...))   | depends only on len of extension
Construction  | list(...)    | O(len(...))   | depends on length of ... iterable

check ==, !=  | l1 == l2     | O(N)          |
Insert        | l[a:b] = ... | O(N)	     |
Delete        | del l[i]     | O(N)	     | depends on i; O(N) in worst case
Containment   | x in/not in l| O(N)	     | linearly searches list 
Copy          | l.copy()     | O(N)	     | Same as l[:] which is O(N)
Remove        | l.remove(...)| O(N)	     | 
Pop	      | l.pop(i)     | O(N)	     | O(N-i): l.pop(0):O(N) (see above)
Extreme value | min(l)/max(l)| O(N)	     | linearly searches list for value
Reverse	      | l.reverse()  | O(N)	     |
Iteration     | for v in l:  | O(N)          | Worst: no return/break in loop

Sort          | l.sort()     | O(N Log N)    | key/reverse mostly doesn't change
Multiply      | k*l          | O(k N)        | 5*l is O(N): len(l)*l is O(N**2)

Tuples support all operations that do not mutate the data structure (and they
have the same complexity classes).


-> len() -->It's O(1) (constant time, not depending of actual length of the element - very fast)
            on every type you've mentioned, plus set and others such as array.array

->  All those objects keep track of their own length. The time to extract the length is 
    small (O(1) in big-O notation) and mostly consists of [rough description, written in Python terms, not C terms]:
    look up "len" in a dictionary and dispatch it to the built_in len function

     which will look up the object's __len__ method and call that ... all it has to do is return self.length


--> n is an O(1) because in your RAM, lists are stored as tables (series of contiguous addresses). 
    To know when the table stops the computer needs two things : length and start point. 
    That is why len() is a O(1), the computer stores the value, so it just needs to look it up
#####################
sys.getsizeof() on the other hand returns the memory size of the object:
Return the size of an object in bytes.
getsizeof() calls the object’s __sizeof__ method and 
adds an additional garbage collector overhead if the
object is managed by the garbage collector
